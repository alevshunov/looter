import {Connection, ConnectionConfig} from "mysql";
import * as mysql from "mysql";
import {ILogger} from './MyLogger';

export class MyConnection {
    private _config: ConnectionConfig;
    private _connection: Connection;
    private _logger: ILogger;

    constructor(config: ConnectionConfig, logger: ILogger) {
        this._config = config;
        this._logger = logger;
    }

    public open() : Promise<MyConnection> {
        return new Promise((resolve, reject) => {
            this._logger.log('Connection create');
            const connection = mysql.createConnection(this._config);

            this._logger.log('Connection connect');
            connection.connect((e: any) => {
                if(e) {
                    this._logger.error(e);
                    this._logger.error(e.stack);

                    return reject(e);
                }
                this._connection = connection;
                resolve(this);
            });
        });
    }

    public query(query: string, ...args: any[]): Promise<Array<any> | any> {
        const me = this;

        const promise = new Promise((resolve, reject) => {
            try {
                const logQuery = query
                    .replace(/\t|\n/g, ' ')
                    .replace(/( +)/g, ' ')
                    .trim();

                this._logger.log('Query', logQuery, JSON.stringify(args));

                const start = Date.now();
                me._connection.query(query, args, (err: any, result: any) => {
                    const elapsed = Date.now() - start;
                    if (err) {
                        me._logger.log('Query Error', JSON.stringify(err));
                        return reject(err);
                    } else {
                        if (result.length > 0) {
                            me._logger.log('Query Success', `${elapsed} ms`, `Fetched ${result.length} lines.`);
                        } else if (result.length === 0) {
                            me._logger.log('Query Success', `${elapsed} ms`, `Fetched ${result.length} lines.`);
                        } else {
                            me._logger.log('Query Success', `${elapsed} ms`, `affectedRows: ${result.affectedRows}, insertId: ${result.insertId}.`);
                        }
                        return resolve(result);
                    }
                });
            } catch(e) {
                me._logger.error(e);
                me._logger.error(e.stack);
                reject(e);
            }
        });

        promise.catch((e) => {
            me._logger.error(JSON.stringify(e));
        });

        return promise;
    }

    public close() {
        const me = this;
        me._logger.log('Connection end');
        this._connection.end(() => {
            me._logger.log('Connection destroy');
            me._connection.destroy();
            me._connection = null;
        });
    }
}